### 第一阶段：数据探查
* **目的**：
> 1. 保障数据质量。
> 1. 方便后阶段的分层构建。
> 1. 方便生产的数据问题排查。

* **实施**：
> 	1. 探查图谱所有涉及到的相关表。
> 	1. 探查相关表的采集策略、数据量大小、时效性、完整性（是否缺少分区）及是否可用问题（表是否下线）（以上情况得满足业务方需求）。
> 	1. 筛选需要用到的相关表字段。
> 	1. 探查相关表字段的用途，例如：是否关联字段、是否筛选字段等。
> 	1. 探查相关表字段的组成结构，为了排查异常值及方便ETL逻辑清洗，例如：该字段是由16位数字组成、以时间戳形式存储还是已YYYY-MM-DD形式存储。
> 	1. 探查相关表字段的缺失值占比、异常值占比情况。
> 	1. 探查相关表字段的上下线情况。
> 	1. 探查相关表的枚举值字段的映射值。
> 	1. 探查相关表的数据是否存在重复性问题（表的最小粒度情况），例如：1张订单表，原则上1笔订单对应1行，但是出现1笔订单对应多行，从1对1变成1对多的情况，这种情况得说明。
> 	1. 探查相关表之间的字段关联、逻辑关联情况，且画出ER关系图，并出逻辑关联说明。
> 	1. 设计实体关系Schema和梳理实体关系的血缘（属性来自哪张表和哪个字段）。

* **产物**：
> 1. 数据质量分析报告。
> 1. 每个单表的探查结果（excel文件）。
> 1. ER关系图（图片文件）。
> 1. 表与表的逻辑关联文字描述（excel文件）。
> 1. 实体关系设计及血缘梳理（excel文件）。
> 1. 以上文件示例参考附件文件。


### 第二阶段：分层构建
#### 贴源层（第一层）
* **模型设计规范**：
> 1. 此层可有可无。前提：如果业务方有直接提供相关表，此层不做，如果只是提供文本文件，此层需做并转换成表。
> 1. 输入：源数据（业务方提供），将单文件转换成单表。
> 1. 不做表与表之间的关联。
> 1. 不做表的聚合操作。
> 1. 不做异常值、缺失值的处理。
> 1. 不做枚举值字段映射的处理。
> 1. 不做新增字段的操作。
> 1. 不做任何处理操作，保持数据的原始性。

* **模型命名规范**：
> 1. 表命名：项目名\_org\_原表名或原文件名\_更新方式(全量、增量)\_更新周期。例如：jftl\_org\_tablename\_f\_d
> 1. 更新方式：f(全量)/a(增量)。
> 1. 更新周期：d(天)、w(周)、m(月)等。
> 1. 字段名：不做更改，保持源数据提供的命名。
> 1. 脚本名：1个表1个脚本，脚本名和贴源层的表命名一样。
> 1. 以上命名统一小写。


#### 适配层（第二层）
* **模型设计规范**：
> 1. 输入：贴源层（第一层），只做单表操作。
> 1. 不做表与表之间的关联。
> 1. 如果单表的关联字段出现异常值或者缺失值，该行直接删除（防止后层表与表关联出现笛卡尔乘积，资源爆炸）
> 1. 处理异常值。处理标准：除非业务有需求，例如规定异常值都为“其他”，负责统一用null代替。
> 1. 处理缺失值。处理标准：除非业务有需求，例如规定异常值都为“其他”，负责统一用null代替。
> 1. 处理枚举值字段的映射。
> 1. 过滤掉不符合业务条件的数据（只根据字段做过滤，例如：订单状态字段，只选择已付款状态，其余过滤），防止后面层级空耗资源。
> 1. 筛选出需要的可用的字段。
> 1. 选取业务方需要的时间范围数据。
> 1. 过滤表中的重复性数据（保证最小粒度，需确定去重逻辑），例如：原表里只出允许出现1笔订单号，但出现了多笔同样的订单号，这种需要做处理。
> 1. 可做单表聚合运算（可选）。
> 1. 可做新增字段的操作（可选，例如根据身份证计算年龄）。

* **模型命名规范**：
> 1. 表命名：项目名\_apt\_原表名\_更新方式(全量、增量)\_更新周期。例如：jftl\_apt\_tablename\_f\_d。
> 1. 更新方式：f(全量)/a(增量)。
> 1. 更新周期：d(天)、w(周)、m(月)等。
> 1. 字段名：不做更改，保持来自贴源层的表的字段的命名。
> 1. 脚本名：1个表1个脚本，脚本名和适配层的表命名一样。
> 1. 以上命名统一小写。


#### 明细层（第三层）
* **模型设计规范**：
> 1. 此层可有可无。前提：如果有指标计算或者实体的属性是需要表关联后再聚合运算得出，此层可做，否则此层不做。
> 1. 输入：适配层（第三层）。
> 1. 做表之间关联，再做汇总、聚合运算。
> 1. 输出表结构：关联实体的字段 + 计算出的实体属性、指标（衍生字段）


* **模型命名规范**：
> 1. 表命名：项目名\_dwd\_实体或关系\_实体名或关系名\_更新方式(全量、增量)\_更新周期。例如：jftl\_dwd\_entity\_person\_f\_d。
> 1. 实体关系：entity(实体)/relation(关系)。
> 1. 更新方式：f(全量)/a(增量)。
> 1. 更新周期：d(天)、w(周)、m(月)等。
> 1. 字段名：统一规范命名（规范：英文全称+下划线+小写）。
> 1. 脚本名：1个实体或者1个关系对应1个脚本，脚本名和明细层的表命名一样。
> 1. 以上命名统一小写。


#### 汇总层（第四层）
* **模型设计规范**：
> 1. 输入：适配层（第二层）+ 明细层（第三层，如果有的话）。
> 1. 做表与表之间的关联，直接生成实体表和关系表。
> 1. 不做汇总、聚合运算。
> 1. 1个实体1张表，1个关系1张表（方便图数据库抽取）。
> 1. 可做新增字段的操作（可选，例如某个指标需要表之间关联后才能计算得出（不涉及聚合运算））。

* **模型命名规范**：
> 1. 表命名：项目名\_dwt\_实体或关系\_实体名或关系名\_更新方式(全量、增量)\_更新周期。例如：jftl\_dwt\_entity\_person\_f\_d。
> 1. 实体关系：entity(实体)/relation(关系)。
> 1. 更新方式：f(全量)/a(增量)。
> 1. 更新周期：d(天)、w(周)、m(月)等。
> 1. 字段名：统一命名。如果汇总层有两个及其以上表，出现字段是统一口径，但命名不一样，需要统一规范命名（规范：英文全称+下划线+小写）。
> 1. 脚本名：1个实体或者1个关系对应1个脚本，脚本名和汇总层的表命名一样。
> 1. 以上命名统一小写。


#### 各层的产物：
> 1. 每层开发脚本（py文件）。
> 1. 每层开发脚本前端部分：得有明确处理逻辑注释（包括关联、聚合、筛选、去重及清洗等逻辑）。
> 1. 每层开发脚本前端部分：得有创建表语句。
> 1. 每层脚本开发完，做个交叉审核，开发人员互相审核代码（防止出错）。


#### 脚本开发规范：
> 1. 目前以pyspark作为开发语言。
> 1. 遵守Python PEP8 编码规范（pycharm IDE可以自动纠正）。
> 1. 统一用下划线命名方式，不采用驼峰命名方法。
> 1. 再创建表语句时，规范化定义数据类型，例如：时间字段用时间类型（date和timestamp等），数值型字段统一用DECIMAL类型（明确整数和小数点各几位）。


